%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Preamble
\documentclass[12pt]{article}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input Commands and Packages
\input{mevansTex}
\input{abbrev}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Header

\title{Optickle}
\author{M.~Evans}
%\address{$^1$MIT Kavli Institute (MKI), Massachusetts Institute of Technology %(MIT), Cambridge, USA;}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document

\begin{document}

\maketitle

\abstract{
Optickle is a general model for the electro-opto-mechanical part of an interferometric GW detector.
It ventures into mechanics only as far as is necessary to include radiation pressure effects, and into electronics only far enough to produce demodulation
signals, and into optics only up to first order.
There are many other tools that do all these things in greater detail.
Optickle is for quick, rough, but essentially complete \ifo\ design studies.}

%%%%%%%%%%%%%%%% PDH
\section{Introduction}

As discussed in previous sections (to be written), Optickle can, in principal, simulate any \ifo.
Once the construction of an Optickle model is finished, all the optics, links and probes added and happily in place, nothing useful has yet been done.
At some point the information represented by the Optickle model must be converted into field amplitudes, transfer functions, and noises.
This is done by the compute functions.
Currently, the fields are all computed by computeFields.
The computeSignals function can then use the field information to the compute signals from all probes.
Noises are not currently computed.
This document will discuss the theory and implementations of these compute functions.

\section{Example System}

In the following sections, I will make frequent attempts to clarify by reference to the example optical system presented in this section.
The example is a Fabry-Perot cavity, composed of two mirrors a source (the laser) and a sink (the photo-detector, see figure \fref{optFP}).

\begin{figure}
\begin{center}
\psfig{figure=optFP.eps,width=12 cm}
\caption{The example system: a Fabry-Perot cavity.
\flabel{optFP}}
\end{center}
\end{figure}

The source is responsible for illuminating the system.
Let's assume that it generates a carrier and 2 RF sidebands from RF phase modulation approximated to first order.
Thus, the frequencies of the field components, relative to the carrier field, are $\vFrf = \group{-f_{mod},0,f_{mod}}$, where $f_{mod}$ is the RF modulation frequency.

The field produced by the source propagates via Link 1 to the back input of Mirror A.
At the end of each link is a "field evaluation point", or FEP.
FEPs are represented by light red balls in figure 1, and are labeled E1, E2, etc.
The field at E1, for example, is clearly just the source field multiplied by the propagation phase determined by the length of Link 1.

The field computation can be described in two parts:  static (DC) fields, and audio frequency (AF) fields.
The DC fields are present in the optical system when none of the optics are driven.
The AF fields are the fields generated by driving the optics.
The following sections describe these computations in detail.

\section{DC Fields}
The collection of DC fields is relatively small:  one for each RF field component, at each field evaluation point (FEP).
That is, $\Nfld = \Nrf \Nlnk$, where $\Nrf$ is the number of RF components and $\Nlnk$ the number of links, such that for our example system $\Nrf = 3, \Nlnk = 4 \Rightarrow \Nfld = 12$.
Despite this not being a very big number, it is enough to make matrices unwieldy and complicated, so for the next few paragraphs I'll use $\vFrf = \group{f_{mod}}$.
To compute the DC fields in the optical system Optickle assumes the steady state equation
\begin{equation}
\vDC = \mDC \vDC + \vSrc
\end{equation}
where $\mDC$ is the optical propagation matrix between FEPs, $\vDC$ is the vector of fields at each FEP, and $\vSrc$ is the vector of injected fields (e.g., from the source in figure 1).
Solving for $\vecv{DC}$
\begin{equation}
\vDC = (\matI - \mDC)^{-1} \vSrc
\elabel{vDC}
\end{equation}
where $\matI$ is the identity matrix.
The sources are given, so $\vSrc$ is known and the computation boils down to computing the inverse of  $\matI - \mDC$.
The propagation matrix is built from the optics and links in the optical system.
For example, the matrix element which takes E4 to E3 is determined by the reflectivity of Mirror A and the length of Link 3.  Thus, this element\footnote{The indexing used in this document will reflect what is used in the Optickle code.
Indices will start at 1, and the colon operator indicates a series of integers (both standard in Matlab).}
of $\mDC$ is
\begin{equation}
\mDC(3,4) = -r_A e^{i 2 \pi ~ f_{mod} ~ l_3 / c}.
\end{equation}

More generally speaking, $\mDC$ is the sum of all of the input to output transfer matrices of all optics, multiplied by the phase induced by the links,
\begin{equation}
\mDC = \mPhi \mOpt
\end{equation}
with
\begin{equation}
\mOpt = \sum_{n=1}^{\Nopt} {\mOutn{n} \mOptn{n} \mInn{n}}.
\elabel{mOpt}
\end{equation}
As shown in the above equation, the contribution of a given optic to the overall transfer matrix is made up of three parts, a matrix which maps FEPs onto the inputs of the optic, the optic's own transfer matrix, and a matrix which maps the optic's outputs back to FEPs.

Taking Mirror A again from our example system (figure \fref{optFP}), and noting that its index is 3, its front input is from FEP 4 and its back input from FEP 1, the corresponding input matrix is
\begin{equation*}
\mInn{3} =
\matrixBegin{cccc}
 0 & 0 & 0 & 1 \\
 1 & 0 & 0 & 0 \\
\matrixEnd.
\end{equation*}
The output matrix, sending the field from the front of Mirror A to FEP 3 and from the back to FEP 2 is
\begin{equation*}
\mOutn{3} =
\matrixBegin{cc}
 0 & 0 \\
 0 & 1 \\
 1 & 0 \\
 0 & 0 \\
\matrixEnd.
\end{equation*}
Finally, assuming that Mirror A has an amplitude transmission coefficient of $t_A$ and an amplitude reflectivity of $r_A$ (which may be complex),
\begin{equation*}
\mOptn{3} =
\matrixBegin{cc}
 -r_A & t_A \\
 t_A & r_A \\
\matrixEnd
.
\end{equation*}

The sum is used in equation \eref{mOpt} to combine the matrices of all optics, though it is expected that no element will contain contributions from more than one optic.
That is, the transfer from one FEP to another happens only through the optic that connects them, which Optickle forces to be unique during construction.

Returning to the full set of RF components in our example system $\vFrf = \group{-f_{mod},0,f_{mod}}$, the matrices for Mirror A are duplicated in block diagonal form with one block for each RF component, becoming
\begin{equation*}
\mInn{3} =
\matrixBegin{cccccccccccc}
 0 & 0 & 0 & 1 & & & & & & & & \\
 1 & 0 & 0 & 0 & & & & & & & & \\
 & & & & 0 & 0 & 0 & 1 & & & & \\
 & & & & 1 & 0 & 0 & 0 & & & & \\
 & & & & & & & & 0 & 0 & 0 & 1 \\
 & & & & & & & & 1 & 0 & 0 & 0 \\
\matrixEnd,
\end{equation*}
\begin{equation*}
\mOutn{3} =
\matrixBegin{cccccc}
 0 & 0 & & & & \\
 0 & 1 & & & & \\
 1 & 0 & & & & \\
 0 & 0 & & & & \\
 & & 0 & 0 & & \\
 & & 0 & 1 & & \\
 & & 1 & 0 & & \\
 & & 0 & 0 & & \\
 & & & & 0 & 0 \\
 & & & & 0 & 1 \\
 & & & & 1 & 0 \\
 & & & & 0 & 0 \\
\matrixEnd,
\end{equation*}
\begin{equation*}
\mOptn{3} =
\matrixBegin{cccccc}
 -r_A & t_A & & & & \\
 t_A & r_A & & & & \\
 & & -r_A & t_A & & \\
 & & t_A & r_A & & \\
 & & & & -r_A & t_A \\
 & & & & t_A & r_A \\
\matrixEnd.
\end{equation*}
Note that the input and output transformations do not change the RF frequency of a field component, and in the case of a mirror, nor does the optic.
However, some optics can convert one RF component to another (e.g., an RF modulator), and this will cause non-zero matrix elements appear in the normally empty off-diagonal areas of the optic's transfer matrix.

Lastly, the propagation phase associated with moving from the input of a link to its output appears in the diagonal matrix
\begin{equation}
\mPhi(k,k) = e^{i ~ \vFrf(m) ~ \vLen(n)}
\elabel{mPhi}
\end{equation}
with $n \in 1:\Nlnk$, $m \in 1:\Nrf$ and $k = n + \Nlnk (m - 1)$.
\begin{equation}
\vLen(n) = 2 \pi ~ l_n / c
\end{equation}

At this point we have constructed $\mDC$ from the parameters of the Optickle model, so we need only put it into equation \eref{vDC} to find the DC field vector $\vDC$.
The result is then used as the seed for computing the response of the system to excitation of one of the optic's internal \dsf, discussed in the following section.

\section{AC Fields}
The computation of AC fields is similar to that of DC fields, except that the optics now play a more active role.
Moving Mirror A at 100Hz, for example, generates 2 audio frequency sidebands on each RF field component of the reflected fields (from E1 into Link 2 and from E4 to Link 3).
AF sidebands, in turn, beat against static fields to produce forces on optics and signals on sensors.

In the AC case, the number of degrees of freedom to be considered more than doubles relative to the DC computation, and the matrices are no longer relationships just between fields, but are generalized to include the optics in the system.
The AC equation analogous to equation \eref{vDC} is
\begin{equation}
\vAC = (\matI - \mAC)^{-1} \vExc
\elabel{vAC}
\end{equation}
where a given excitation vector produces a vector of audio sideband fields.
A further transformation, determined by the probes place in the system, converts fields to signals
\begin{equation}
\vSig = \mPrb (\matI - \mAC)^{-1} \vExc
\elabel{vSig}
\end{equation}
The transfer matrix, from normalized excitations to signals, is thus just the core of the above equation,
\begin{equation}
\mTF = \mPrb (\matI - \mAC)^{-1}
\elabel{mTF}.
\end{equation}
This matrix is one of the primary results produced by the Optickle compute function.

In Optickle the audio frequency transfer matrix, $\mAC$, is constructed in blocks
\begin{equation}
\mAC =
\matrixBegin{cc}
 \matm{field-field} & \matm{optic-field} \\
 \matm{field-optic} & 0 \\
\matrixEnd
.
\end{equation}
where $\matm{field-field}$ is a matrix similar to $\mDC$ which represents transfers among fields, though in this case they are AF sideband fields.
The $\matm{optic-optic}$ matrix is missing as the optics' degrees of freedom are assumed to be decoupled.
As the names indicate, $\matm{optic-field}$ and $\matm{field-optic}$ represent the relationships between the optics' degrees of freedom and the AF sideband fields.
The following sections will describe the construction of each of these matrices in detail.

\subsection{Field to Optic Transfer Matrix}
This matrix is actually the product of the field-to-force matrix, and the force-to-degree of freedom matrix, where ``degree of freedom'' most often means ``position''.
\begin{equation}
\matm{field-optic} = \mMech \matm{field-force}
\end{equation}

To compute the force available for generating mechanical motion, we start with the force exerted on a perfect absorber
\begin{equation}
F_0 = (E^*_{DC} E_{-} + E_{DC} E^*_{+}) e^{-i 2 \pi f_{AF} t} / c,
\elabel{force}
\end{equation}
where the audio frequency phase rotation part has been factored out of the audio sideband amplitudes, $E_{-}$ and $E_{+}$,
and the DC and AF fields are both associated with the same RF component.
A not normally noteworthy feature of equation \eref{force} is that the upper audio sideband appears conjugated.
This has implications for the matrix world of Optickle, since matrices do not usually contain conjugation operators.
To side-step this problem, the conjugate of the upper sideband is propagated throughout the system with appropriately conjugated operators.

The matrix $\mMech$ is typically the mechanical response of the optics to radiation pressure induced force, summed over all optics in the system,
\begin{equation}
\mMech = \sum^{\Nopt}_{n=1} \mDOFn{n} \mMechn{n} \mInn{n}
\elabel{mMech}
\end{equation}
where $\mDOFn{n}$ is the matrix which maps the internal \dsf\ of the $n^{th}$ optic onto the system wide \dsf.
$\matm{field-force}$ comes directly from equation \eref{force},
\begin{equation}
\matm{field-force} =
\matrixBegin{cc}
 \tfun{diag}{\vDC}^* & \tfun{diag}{\vDC} \\
\matrixEnd / c
\end{equation}
were ``diag'' is Matlab notation for ``a square matrix with this vector along the diagonal.''

Expanding our discussion to TEM01 and 10 modes would lead us to consider the field-to-torque and torque-to-angle matrices, but we can save that for later.

\subsection{Field to Field Transfer Matrix}
This part of  is almost identical to $\mDC$, the major differences being that for each RF component 2 AF sidebands must be computed, and that the propagation phase associated with the links must account for the sum of the RF and AF phases.
Restating,
\begin{equation}
\matm{field-field} =
\matrixBegin{cc}
 \mPhin{-} \mOpt & 0 \\
 0 & \mPhin{+}^* \mOpt^* \\
\matrixEnd
\end{equation}
where in this case the link phase is
\begin{equation}
\mPhin{\pm}(k,k) = e^{i ~ (\vFrf(m) \pm f_{AF}) ~ \vLen(n)}
\end{equation}
which is the same as equation \eref{mPhi}, with the addition of the audio frequency component.
The conjugation of the upper sideband component is a result of equation \eref{force}, as mentioned earlier.

\subsection{Optic to Field Transfer Matrix}
The optic to field matrix, much like the field to field matrix, must generate both upper and lower audio sidebands at FEPs, so it is constructed as
\begin{equation}
\matm{optic-field} =
\matrixBegin{c}
 \mPhin{-} \mGen \\
 \mPhin{+}^* \mGen^* \\
\matrixEnd
\elabel{mOF}
\end{equation}
As with $\matm{field-optic}$, the matrix $\mGen$ is composed of an optic specified matrix, and DC fields.  The DC fields are present as source fields which the optics modulate to produce audio SBs,
\begin{equation}
\mGen(:,k_{n,m}) = \mModn{n,m} \vDC
\end{equation}
where $\mModn{n,m}$ is the modulation produced by driving an optic $n$, \dof\ $m$.
The indices are $n \in 1:\Nopt$, $m \in 1:N_{dof_n}$, and $k_{n,m}$ is the map of system \dsf\ to optics internal \dsf.
$k_{n,m}$ is related to $\mDOFn{n}$ by
\begin{equation}
\mDOFn{n}(k_{n,m}, m) = 1
\end{equation}
with all other elements of $\mDOFn{n} = 0$.
This mapping is a bit ugly, but it can only be avoided by using higher dimensional tensors, which seem even less appealing.

The matrix $\mModn{n,m}$ is the modulation matrix for the $m^{th}$ \dof\ of the $n^{th}$ optic, $x_{n,m}$, which can be written in terms of $\mOptn{n}$
\begin{equation}
\mModn{n,m} = \mOutn{n} \partderiv{\mOptn{n}}{x_{n,m}} \mInn{n}
\elabel{mMod}
\end{equation}
with the usual input and output transforms in place to map the source fields in and the generated audio-sidebands out.
After the output mapping, $\mPhi$ appears in equation \eref{mOF} to carry the audio-sidebands from the output of the optics where they are generated, which are inputs of the associated links, to the FEPs at the outputs of the links.

\section{Signal Production}
Converting DC and audio frequency fields to signals, performed by $\mPrb$ introduced in equation \eref{vSig}, results from power fluctuation measured by the probe and is thus very similar to the radiation pressure interaction described in $\matm{field-optic}$.
The major difference is that probes can demodulate signals at RF frequencies, thereby mixing RF components in their outputs.
To compute the signal at some frequency we start with an expression for the intensity present at a given FEP,
\begin{equation}
I = \sum^{\Nrf}_{m = 1} \sum^{\Nrf}_{n = m}
(E^*_{DC_n} E_{-_m} + E_{DC_m} E^*_{+_n})
 e^{-i 2 \pi (\vFrf(n) - \vFrf(m) + f_{AF}) t}
\elabel{intensity}
\end{equation}
Requiring that the output be at the demodulation frequency $f_{demod}$, plus the audio modulation frequency $f_{AF}$, such that the integral
\begin{equation}
S = \int^{\infty}_{-\infty} I e^{i 2 \pi (f_{demod} + f_{AF}) t} dt
\end{equation}
is not zero removes most of the terms in the sum in equation \eref{intensity} by introducing a delta function
\begin{equation}
S = \sum^{\Nrf}_{m = 1} \sum^{\Nrf}_{n = m}
(E^*_{DC_n} E_{-_m} + E_{DC_m} E^*_{+_n})
 \fun{\delta}{f_{demod} - \vFrf(n) + \vFrf(m)}.
\end{equation}
The demodulation matrix expresses this 

\section{Quantum Noise}

Computed by injecting AF SB at each loss point, unconnected port, and source.
Some serious discussion is needed here.

\section{Parting Example}

A quick example of how to run the compute function and how to interpret its results.

\end{document}
